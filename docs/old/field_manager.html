<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=EUC-JP">
<title>Module field_manager_mod</title>
<link type="text/css" href="http://www.gfdl.noaa.gov/~fms/style/doc.css" rel="stylesheet">
<STYLE TYPE="text/css">
          .fixed {
            font-size:medium;
            font-family:monospace;
            border-style:none;
            border-width:0.1em;
            padding:0.1em;
            color:#663366;
          }
        </STYLE>
</head>
<body>
<a name="TOP"></a><font class="header" size="1"><a href="#PUBLIC INTERFACE">PUBLIC INTERFACE </a>~
          <a href="#PUBLIC DATA">PUBLIC DATA </a>~
          <a href="#PUBLIC ROUTINES">PUBLIC ROUTINES </a>~
          <a href="#NAMELIST">NAMELIST </a>~
          <a href="#DIAGNOSTIC FIELDS">DIAGNOSTIC FIELDS </a>~
          <a href="#ERROR MESSAGES">ERROR MESSAGES </a>~
          <a href="#REFERENCES">REFERENCES </a>~ 
          <a href="#NOTES">NOTES</a></font>
<hr>
<h2>Module field_manager_mod</h2>
<a name="HEADER"></a>
<!-- BEGIN HEADER -->
<div>
<b>Contact:&nbsp;</b><a href="mailto:William.Cooke@noaa.gov">   William Cooke </a>
<br>
<b>Reviewers:&nbsp;</b><a href="mailto:Richard.Slater@noaa.gov">   Richard D. Slater </a>,&nbsp;
    <a href="mailto:Matthew.Harrison@noaa.gov">   Matthew Harrison </a>,&nbsp;
    <a href="mailto:John.Dunne@noaa.gov">   John P. Dunne </a>
<br>
<b>Change History:&nbsp;</b><a href="http://www.gfdl.noaa.gov/fms-cgi-bin/cvsweb.cgi/FMS/shared/field_manager">WebCVS Log</a>
<br>
<br>
</div>
<!-- END HEADER -->
<a name="OVERVIEW"></a>
<hr>
<h4>OVERVIEW</h4>
<!-- BEGIN OVERVIEW -->
<p class="text">   The field manager reads entries from a field table and stores this
   information along with the type  of field it belongs to. This allows
   the component models to query the field manager to see if  non-default
   methods of operation are desired. In essence the field table is a
   powerful type of namelist. Default values can be provided for all the
   fields through a namelist, individual fields can be modified  through
   the field table however. </p>
<!-- END OVERVIEW -->
<a name="DESCRIPTION"></a>
<!-- BEGIN DESCRIPTION -->
<div>   An example of field table entries could be <pre>"tracer","atmos_mod","sphum"/

"tracer","atmos_mod","sf6"
"longname","sulf_hex"
"advection_scheme_horiz","2nd_order"
"Profile_type","Fixed","surface_value = 0.0E+00"/

"prog_tracers","ocean_mod","age_global"
horizontal-advection-scheme = mdfl_sweby
vertical-advection-scheme = mdfl_sweby
file_in = INPUT/ocean_age.res.nc
file_out = RESTART/ocean_age.res.nc/</pre>   The field table consists of entries in the following format.
   <br>
<br>
   The first line of an entry should consist of three quoted strings.
   <br>
<br>
   The first quoted string will tell the field manager what type of 
   field it is.
   <br>
<br>
   The second quoted string will tell the field manager which model the 
   field is being applied to.
   The supported types at present are <pre>      "coupler_mod" for the coupler,
      "atmos_mod" for the atmosphere model,
      "ocean_mod" for the ocean model,
      "land_mod" for the land model, and,
      "ice_mod" for the ice model.</pre>   The third quoted string should be a unique name that can be used as a
   query.
   <br>
<br>
   The second and following lines of each entry are called methods in
   this context. Methods can be developed within any module and these
   modules can query the field manager to find any methods that are
   supplied in the field table.
   <br>
<br>
   These lines can be coded quite flexibly.
   <br>
<br>
   The line can consist of two or three quoted strings or a simple unquoted 
   string.
   <br>
<br>
   If the line consists two or three quoted strings, then the first string will 
   be an identifier that the querying module will ask for.
   <br>
<br>
   The second string will be a name that the querying module can use to
   set up values for the module. 
   <br>
<br>
   The third string, if present, can supply parameters to the calling module that can be
   parsed and used to further modify values.
   <br>
<br>
   If the line consists of a simple unquoted string then quotes are not allowed 
   in any part of the line.
   <br>
<br>
   An entry is ended with a backslash (/) as the final character in a
   row.
   <br>
<br>
   Comments can be inserted in the field table by having a # as the
   first character in the line.
   <br>
<br>
   In the example above we have three field entries. 
   <br>
<br>
   The first is a simple declaration of a tracer called "sphum". 
   <br>
<br>
   The second is for a tracer called "sf6". In this case a field named
   "longname" will be given the value "sulf_hex". A field named 
   "advection_scheme_horiz" will be given the value "2nd_order". Finally a field
   name "Profile_type" will be given a child field called "Fixed", and that field
   will be given a field called "surface_value" with a real value of 0.0E+00.
   <br>
<br>
   The third entry is an example of a oceanic age tracer. Note that the 
   method lines are formatted differently here. This is the flexibility mentioned 
   above.
   <br>
<br>
   With these formats, a number of restrictions are required. 
   <br>
<br>
   The following formats are equally valid. <pre>      "longname","sulf_hex"
      "longname = sulf_hex"
      longname = sulf_hex</pre>   However the following is not valid. <pre>      longname = "sulf_hex"</pre>   In the SF6 example above the last line of the entry could be written in the 
   following ways. <pre>      "Profile_type","Fixed","surface_value = 0.0E+00"/
      Profile_type/Fixed/surface_value = 0.0E+00/</pre>   Values supplied with fields are converted to the various types with the
   following assumptions. <pre> Real values : These values contain a decimal point or are in exponential format.
    These values only support e or E format for exponentials.
    e.g. 10.0, 1e10 and 1E10 are considered to be real numbers.

 Integer values : These values only contain numbers. 
    e.g 10 is an integer. 10.0 and 1e10 are not.

 Logical values : These values are supplied as one of the following formats.
    T, .T., TRUE, .TRUE.
    t, .t., true, .true.
    F, .F., FALSE, .FALSE.
    f, .f., false, .false.
    These will be converted to T or F in a dump of the field.

 Character strings : These values are assumed to be strings if a character 
    other than an e (or E) is in the value. Numbers can be suppled in the value.
    If the value does not meet the criteria for a real, integer or logical type,
    it is assumed to be a character type.</pre>   The entries within the field table can be designed by the individual
   authors of code to allow modification of their routines.
   <br>
<br> 
</div>
<br>
<!-- END DESCRIPTION -->
<a name="OTHER MODULES USED"></a>
<hr>
<h4>OTHER MODULES USED</h4>
<!-- BEGIN OTHER MODULES USED -->
<div>
<pre>   mpp_mod<br>mpp_io_mod<br>   fms_mod</pre>
</div>
<!-- END OTHER MODULES USED -->
<!-- BEGIN PUBLIC INTERFACE -->
<a name="PUBLIC INTERFACE"></a>
<hr>
<h4>PUBLIC INTERFACE</h4>
<div>
<dl>
<dt>
<a href="#field_manager_init">field_manager_init</a>:</dt>
<dd>   Routine to initialize the field manager. </dd>
<dt>
<a href="#field_manager_end">field_manager_end</a>:</dt>
<dd>   Destructor for field manager. </dd>
<dt>
<a href="#strip_front_blanks">strip_front_blanks</a>:</dt>
<dd>   A routine to strip whitespace from the start of character strings. </dd>
<dt>
<a href="#find_field_index">find_field_index</a>:</dt>
<dd>   Function to return the index of the field. </dd>
<dt>
<a href="#get_field_info">get_field_info</a>:</dt>
<dd>   This routine allows access to field information given an index. </dd>
<dt>
<a href="#get_field_method">get_field_method</a>:</dt>
<dd>   A routine to get a specified method. </dd>
<dt>
<a href="#get_field_methods">get_field_methods</a>:</dt>
<dd>   A routine to obtain all the methods associated with a field. </dd>
<dt>
<a href="#parse">parse</a>:</dt>
<dd>   A function to parse an integer or an array of integers, 
   a real or an array of reals, a string or an array of strings. </dd>
<dt>
<a href="#fm_change_list">fm_change_list</a>:</dt>
<dd>   Change the current list. Return true on success,
   false otherwise </dd>
<dt>
<a href="#fm_change_root">fm_change_root</a>:</dt>
<dd>   Change the root list </dd>
<dt>
<a href="#fm_dump_list">fm_dump_list</a>:</dt>
<dd>   A function to list properties associated with a field. </dd>
<dt>
<a href="#fm_exists">fm_exists</a>:</dt>
<dd>   A function to test whether a named field exists. </dd>
<dt>
<a href="#fm_get_index">fm_get_index</a>:</dt>
<dd>   A function to return the index of a named field. </dd>
<dt>
<a href="#fm_get_current_list">fm_get_current_list</a>:</dt>
<dd>   A function to return the full path of the current list. </dd>
<dt>
<a href="#fm_get_length">fm_get_length</a>:</dt>
<dd>   A function to return how many elements are contained within the named 
   list or entry. </dd>
<dt>
<a href="#fm_get_type">fm_get_type</a>:</dt>
<dd>   A function to return the type of the named field. </dd>
<dt>
<a href="#fm_get_value">fm_get_value</a>:</dt>
<dd>   An overloaded function to find and extract a value for a named field. </dd>
<dt>
<a href="#fm_intersection">fm_intersection</a>:</dt>
<dd>   A function to find the common names of the sub-fields in a list 
   of fields. </dd>
<dt>
<a href="#fm_loop_over_list">fm_loop_over_list</a>:</dt>
<dd>   A function for looping over a list. </dd>
<dt>
<a href="#fm_new_list">fm_new_list</a>:</dt>
<dd>   A function to create a new list. </dd>
<dt>
<a href="#fm_new_value">fm_new_value</a>:</dt>
<dd>   An overloaded function to assign a value to a field. </dd>
<dt>
<a href="#fm_reset_loop">fm_reset_loop</a>:</dt>
<dd>   Resets the loop variable. For use in conjunction with fm_loop_over_list. </dd>
<dt>
<a href="#fm_return_root">fm_return_root</a>:</dt>
<dd>   Return the root list to the value at initialization </dd>
<dt>
<a href="#fm_modify_name">fm_modify_name</a>:</dt>
<dd>   This function allows a user to rename a field without modifying the 
   contents of the field. </dd>
<dt>
<a href="#fm_query_method">fm_query_method</a>:</dt>
<dd>   This is a function that provides the capability to return parameters 
   associated with a field in a pair of strings. </dd>
<dt>
<a href="#fm_copy_list">fm_copy_list</a>:</dt>
<dd>   A function that allows the user to copy a field and add a suffix to 
   the name of the new field. </dd>
<dt>
<a href="#fm_find_methods">fm_find_methods</a>:</dt>
<dd>   This function retrieves all the methods associated with a field. </dd>
<dt>
<a href="#fm_set_verbosity">fm_set_verbosity</a>:</dt>
<dd>   A subroutine to set the verbosity of the field manager output. </dd>
</dl>
</div>
<br>
<!-- END PUBLIC INTERFACE -->
<a name="PUBLIC DATA"></a>
<hr>
<h4>PUBLIC DATA</h4>
<!-- BEGIN PUBLIC DATA -->
<div>
<table align="center" cellspacing="2" CELLPADDING="2" BORDER="2">
<tr>
<th> Name  </th><th> Type  </th><th> Value  </th><th> Units  </th><th> Description  </th>
</tr>
<tr>
<td> fm_field_name_len  </td><td> integer, parameter  </td><td> 32  </td><td> ---  </td><td>    The length of a character string representing the field name.   </td>
</tr>
<tr>
<td> fm_path_name_len  </td><td> integer, parameter  </td><td> 512  </td><td> ---  </td><td>    The length of a character string representing the field path.   </td>
</tr>
<tr>
<td> fm_string_len  </td><td> integer, parameter  </td><td> 128  </td><td> ---  </td><td>    The length of a character string representing character values for the field.   </td>
</tr>
<tr>
<td> fm_type_name_len  </td><td> integer, parameter  </td><td> 8  </td><td> ---  </td><td>    The length of a character string representing the various types that the values of the field can take.   </td>
</tr>
<tr>
<td> NUM_MODELS  </td><td> integer, parameter  </td><td> 5  </td><td> ---  </td><td>    Number of models (ATMOS, OCEAN, LAND, ICE, COUPLER).   </td>
</tr>
<tr>
<td> NO_FIELD  </td><td> integer, parameter  </td><td> -1  </td><td> ---  </td><td>    The value returned if a field is not defined.   </td>
</tr>
<tr>
<td> MODEL_ATMOS  </td><td> integer, parameter  </td><td> 1  </td><td> ---  </td><td>    Atmospheric model.   </td>
</tr>
<tr>
<td> MODEL_OCEAN  </td><td> integer, parameter  </td><td> 2  </td><td> ---  </td><td>    Ocean model.   </td>
</tr>
<tr>
<td> MODEL_LAND  </td><td> integer, parameter  </td><td> 3  </td><td> ---  </td><td>    Land model.   </td>
</tr>
<tr>
<td> MODEL_ICE  </td><td> integer, parameter  </td><td> 4  </td><td> ---  </td><td>    Ice model.   </td>
</tr>
<tr>
<td> MODEL_COUPLER  </td><td> integer, parameter  </td><td> 5  </td><td> ---  </td><td>    Ice model.   </td>
</tr>
<tr>
<td> MODEL_NAMES  </td><td> character(len=11), parameter  </td><td> ---  </td><td> ---  </td><td>    Model names, e.g. MODEL_NAMES(MODEL_OCEAN) is 'oceanic'   </td>
</tr>
</table>
<br>
</div>
<!-- END PUBLIC DATA -->
<a name="PUBLIC ROUTINES"></a>
<hr>
<h4>PUBLIC ROUTINES</h4>
<!-- BEGIN PUBLIC ROUTINES -->
<ol type="a">
<li>
<a name="field_manager_init"></a>
<h4>field_manager_init</h4>
<pre>
<b>call field_manager_init </b>(nfields, table_name)</pre>
<dl>
<dt>
<b>DESCRIPTION</b>
</dt>
<dd>   This routine reads from a file containing formatted strings. 
   These formatted strings contain information on which schemes are
   needed within various modules. The field manager does not
   initialize any of those schemes however. It simply holds the
   information and is queried by the appropriate  module. </dd>
<br>
<br>
<dt>
<b>INPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>table_name&nbsp;&nbsp;&nbsp;</tt></td><td>   The name of the field table. The default name is field_table. <br>&nbsp;&nbsp;&nbsp;<span class="type">[character, optional, dimension(len=128)]</span></td>
</tr>
</table>
</dd>
<br>
<dt>
<b>OUTPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>nfields&nbsp;&nbsp;&nbsp;</tt></td><td>   The number of fields. <br>&nbsp;&nbsp;&nbsp;<span class="type">[integer]</span></td>
</tr>
</table>
</dd>
<br>
</dl>
</li>
<li>
<a name="field_manager_end"></a>
<h4>field_manager_end</h4>
<pre>
<b>call field_manager_end </b>
</pre>
<dl>
<dt>
<b>DESCRIPTION</b>
</dt>
<dd>   This subroutine writes to the logfile that the user is exiting field_manager and 
   changes the initialized flag to false. </dd>
<br>
<br>
</dl>
</li>
<li>
<a name="strip_front_blanks"></a>
<h4>strip_front_blanks</h4>
<pre>
<b>call strip_front_blanks </b>(name)</pre>
<dl>
<dt>
<b>DESCRIPTION</b>
</dt>
<dd>   This subroutine removes spaces and tabs from the start of a character string. </dd>
<br>
<br>
</dl>
</li>
<li>
<a name="find_field_index"></a>
<h4>find_field_index</h4>
<pre>value= <b>find_field_index</b> ( model, field_name ) value=find_field_index( field_name )</pre>
<dl>
<dt>
<b>DESCRIPTION</b>
</dt>
<dd>   This function when passed a model number and a field name will 
   return the index of the field within the field manager. This index 
   can be used to access other information from the field manager. </dd>
<br>
<br>
<dt>
<b>INPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>model&nbsp;&nbsp;&nbsp;</tt></td><td>   The number indicating which model is used. <br>&nbsp;&nbsp;&nbsp;<span class="type">[integer]</span></td>
</tr>
<tr>
<td valign="top" align="left"><tt>field_name&nbsp;&nbsp;&nbsp;</tt></td><td>   The name of the field that an index is being requested for. <br>&nbsp;&nbsp;&nbsp;<span class="type">[character]</span></td>
</tr>
<tr>
<td valign="top" align="left"><tt>field_name&nbsp;&nbsp;&nbsp;</tt></td><td>   The path to the name of the field that an index is being requested for. <br>&nbsp;&nbsp;&nbsp;<span class="type">[character]</span></td>
</tr>
</table>
</dd>
<br>
<dt>
<b>OUTPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>find_field_index&nbsp;&nbsp;&nbsp;</tt></td><td>   The index of the field corresponding to field_name. <br>&nbsp;&nbsp;&nbsp;<span class="type">[integer]</span></td>
</tr>
<tr>
<td valign="top" align="left"><tt>find_field_index&nbsp;&nbsp;&nbsp;</tt></td><td>   The index of the field corresponding to field_name. <br>&nbsp;&nbsp;&nbsp;<span class="type">[integer]</span></td>
</tr>
</table>
</dd>
<br>
</dl>
</li>
<li>
<a name="get_field_info"></a>
<h4>get_field_info</h4>
<pre>
<b>call get_field_info </b>( n,fld_type,fld_name,model,num_methods )</pre>
<dl>
<dt>
<b>DESCRIPTION</b>
</dt>
<dd>   When passed an index, this routine will return the type of field, 
   the name of the field, the model which the field is associated and 
   the number of methods associated with the field. </dd>
<br>
<br>
<dt>
<b>INPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>n&nbsp;&nbsp;&nbsp;</tt></td><td>   The field index. <br>&nbsp;&nbsp;&nbsp;<span class="type">[integer]</span></td>
</tr>
</table>
</dd>
<br>
<dt>
<b>OUTPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>fld_type&nbsp;&nbsp;&nbsp;</tt></td><td>   The field type. <br>&nbsp;&nbsp;&nbsp;<span class="type">[character, dimension(*)]</span></td>
</tr>
<tr>
<td valign="top" align="left"><tt>fld_name&nbsp;&nbsp;&nbsp;</tt></td><td>   The name of the field. <br>&nbsp;&nbsp;&nbsp;<span class="type">[character, dimension(*)]</span></td>
</tr>
<tr>
<td valign="top" align="left"><tt>model&nbsp;&nbsp;&nbsp;</tt></td><td>   The number indicating which model is used. <br>&nbsp;&nbsp;&nbsp;<span class="type">[integer]</span></td>
</tr>
<tr>
<td valign="top" align="left"><tt>num_methods&nbsp;&nbsp;&nbsp;</tt></td><td>   The number of methods. <br>&nbsp;&nbsp;&nbsp;<span class="type">[integer]</span></td>
</tr>
</table>
</dd>
<br>
</dl>
</li>
<li>
<a name="get_field_method"></a>
<h4>get_field_method</h4>
<pre>
<b>call get_field_method </b>( n,m,method )</pre>
<dl>
<dt>
<b>DESCRIPTION</b>
</dt>
<dd>   This routine, when passed a field index and a method index will 
   return the method text associated with the field(n) method(m). </dd>
<br>
<br>
<dt>
<b>INPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>n&nbsp;&nbsp;&nbsp;</tt></td><td>   The field index. <br>&nbsp;&nbsp;&nbsp;<span class="type">[integer]</span></td>
</tr>
<tr>
<td valign="top" align="left"><tt>m&nbsp;&nbsp;&nbsp;</tt></td><td>   The method index. <br>&nbsp;&nbsp;&nbsp;<span class="type">[integer]</span></td>
</tr>
</table>
</dd>
<br>
<dt>
<b>OUTPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>method&nbsp;&nbsp;&nbsp;</tt></td><td>   The m-th method of field with index n. <br>&nbsp;&nbsp;&nbsp;<span class="type">[type(method_type)]</span></td>
</tr>
</table>
</dd>
<br>
</dl>
</li>
<li>
<a name="get_field_methods"></a>
<h4>get_field_methods</h4>
<pre>
<b>call get_field_methods </b>( n,methods )</pre>
<dl>
<dt>
<b>DESCRIPTION</b>
</dt>
<dd>   When passed a field index, this routine will return the text 
   associated with all the methods attached to the field. </dd>
<br>
<br>
<dt>
<b>INPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>n&nbsp;&nbsp;&nbsp;</tt></td><td>   The field index. <br>&nbsp;&nbsp;&nbsp;<span class="type">[integer]</span></td>
</tr>
</table>
</dd>
<br>
<dt>
<b>OUTPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>method&nbsp;&nbsp;&nbsp;</tt></td><td>   An array of methods for field with index n. <br>&nbsp;&nbsp;&nbsp;<span class="type">[type(method_type), dimension(:)]</span></td>
</tr>
</table>
</dd>
<br>
</dl>
</li>
<li>
<a name="parse"></a>
<h4>parse</h4>
<pre>number = <b>parse</b> (text, label, value)</pre>
<dl>
<dt>
<b>DESCRIPTION</b>
</dt>
<dd>   Parse is an integer function that decodes values from a text string.
   The text string has the form: "label=list" where "label" is an
   arbitrary user defined label describing the values being decoded,
   and "list" is a list of one or more values separated by commas.
   The values may be integer, real, or character.
   Parse returns the number of values decoded. </dd>
<br>
<br>
<dt>
<b>INPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>text&nbsp;&nbsp;&nbsp;</tt></td><td>   The text string from which the values will be parsed. <br>&nbsp;&nbsp;&nbsp;<span class="type">[character(len=*)]</span></td>
</tr>
<tr>
<td valign="top" align="left"><tt>label&nbsp;&nbsp;&nbsp;</tt></td><td>   A label which describes the values being decoded. <br>&nbsp;&nbsp;&nbsp;<span class="type">[character(len=*)]</span></td>
</tr>
</table>
</dd>
<br>
<dt>
<b>OUTPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>value&nbsp;&nbsp;&nbsp;</tt></td><td>   The value or values that have been decoded. <br>&nbsp;&nbsp;&nbsp;<span class="type">[integer, real, character(len=*)]</span></td>
</tr>
<tr>
<td valign="top" align="left"><tt>parse&nbsp;&nbsp;&nbsp;</tt></td><td>   The number of values that have been decoded. This allows 
   a user to define a large array and fill it partially with 
   values from a list. This should be the size of the value array. <br>&nbsp;&nbsp;&nbsp;<span class="type">[integer]</span></td>
</tr>
</table>
</dd>
<br>
</dl>
</li>
<li>
<a name="fm_change_list"></a>
<h4>fm_change_list</h4>
<pre>success = <b>fm_change_list</b> (name)</pre>
<dl>
<dt>
<b>DESCRIPTION</b>
</dt>
<dd>   This function changes the currect list to correspond to the list named name.
   If the first character of name is the list separator (/) then the list will 
   search for "name" starting from the root of the field tree. Otherwise it 
   will search for name starting from the current list. </dd>
<br>
<br>
<dt>
<b>INPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>name&nbsp;&nbsp;&nbsp;</tt></td><td>   The name of a list that the user wishes to change to. <br>&nbsp;&nbsp;&nbsp;<span class="type">[character(len=*)]</span></td>
</tr>
</table>
</dd>
<br>
<dt>
<b>OUTPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>success&nbsp;&nbsp;&nbsp;</tt></td><td>   A flag to indicate whether the function operated with (FALSE) or 
   without (TRUE) errors. <br>&nbsp;&nbsp;&nbsp;<span class="type">[logical]</span></td>
</tr>
</table>
</dd>
<br>
</dl>
</li>
<li>
<a name="fm_change_root"></a>
<h4>fm_change_root</h4>
<pre>success = <b>fm_change_root</b> (name)</pre>
<dl>
<dt>
<b>DESCRIPTION</b>
</dt>
<dd>   This function changes the root of the field tree to correspond to the 
   field named name. An example of a use of this would be if code is 
   interested in a subset of fields with a common base. This common base 
   could be set using fm_change_root and fields could be referenced using 
   this root. 
   <br>
<br>
   This function should be used in conjunction with fm_return_root.
   <br>
<br> 
</dd>
<br>
<br>
<dt>
<b>INPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>name&nbsp;&nbsp;&nbsp;</tt></td><td>   The name of the field which the user wishes to become the root. <br>&nbsp;&nbsp;&nbsp;<span class="type">[character(len=*)]</span></td>
</tr>
</table>
</dd>
<br>
<dt>
<b>OUTPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>success&nbsp;&nbsp;&nbsp;</tt></td><td>   A flag to indicate whether the function operated with (FALSE) or 
   without (TRUE) errors. <br>&nbsp;&nbsp;&nbsp;<span class="type">[logical]</span></td>
</tr>
</table>
</dd>
<br>
</dl>
</li>
<li>
<a name="fm_dump_list"></a>
<h4>fm_dump_list</h4>
<pre>success = <b>fm_dump_list</b> (name, recursive = .true.)</pre>
<dl>
<dt>
<b>DESCRIPTION</b>
</dt>
<dd>   This function writes the contents of the field named "name" to stdout.
   If recursive is present and .true., then this function writes out the 
   contents of any subfields associated with the field named "name". </dd>
<br>
<br>
<dt>
<b>INPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>name&nbsp;&nbsp;&nbsp;</tt></td><td>   The name of the field for which output is requested. <br>&nbsp;&nbsp;&nbsp;<span class="type">[character(len=*)]</span></td>
</tr>
<tr>
<td valign="top" align="left"><tt>recursive&nbsp;&nbsp;&nbsp;</tt></td><td>   If present and .true., then a recursive listing of fields will be
   performed. <br>&nbsp;&nbsp;&nbsp;<span class="type">[logical, optional]</span></td>
</tr>
</table>
</dd>
<br>
<dt>
<b>OUTPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>success&nbsp;&nbsp;&nbsp;</tt></td><td>   A flag to indicate whether the function operated with (FALSE) or 
   without (TRUE) errors. <br>&nbsp;&nbsp;&nbsp;<span class="type">[logical]</span></td>
</tr>
</table>
</dd>
<br>
</dl>
</li>
<li>
<a name="fm_exists"></a>
<h4>fm_exists</h4>
<pre>success = <b>fm_exists</b> (name)</pre>
<dl>
<dt>
<b>DESCRIPTION</b>
</dt>
<dd>   This function determines is a field exists, relative to the current list,
   and returns true if the list exists, false otherwise. </dd>
<br>
<br>
<dt>
<b>INPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>name&nbsp;&nbsp;&nbsp;</tt></td><td>   The name of the field that is being queried. <br>&nbsp;&nbsp;&nbsp;<span class="type">[character(len=*)]</span></td>
</tr>
</table>
</dd>
<br>
<dt>
<b>OUTPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>success&nbsp;&nbsp;&nbsp;</tt></td><td>   A flag to indicate whether the function operated with (FALSE) or 
   without (TRUE) errors. <br>&nbsp;&nbsp;&nbsp;<span class="type">[logical]</span></td>
</tr>
</table>
</dd>
<br>
</dl>
</li>
<li>
<a name="fm_get_index"></a>
<h4>fm_get_index</h4>
<pre>index = <b>fm_get_index</b> (name)</pre>
<dl>
<dt>
<b>DESCRIPTION</b>
</dt>
<dd>   Returns the index for name, returns the parameter NO_FIELD if it does not
   exist. If the first character of the named field is the list peparator, 
   then the named field will be relative to the root of the field tree. 
   Otherwise the named field will be relative to the current list. </dd>
<br>
<br>
<dt>
<b>INPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>name&nbsp;&nbsp;&nbsp;</tt></td><td>   The name of a field that the user wishes to get an index for. <br>&nbsp;&nbsp;&nbsp;<span class="type">[character(len=*)]</span></td>
</tr>
</table>
</dd>
<br>
<dt>
<b>OUTPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>index&nbsp;&nbsp;&nbsp;</tt></td><td>   The index of the named field if it exists. 
   Otherwise the parameter NO_FIELD. <br>&nbsp;&nbsp;&nbsp;<span class="type">[index]</span></td>
</tr>
</table>
</dd>
<br>
</dl>
</li>
<li>
<a name="fm_get_current_list"></a>
<h4>fm_get_current_list</h4>
<pre>path = <b>fm_get_current_list</b> ()</pre>
<dl>
<dt>
<b>DESCRIPTION</b>
</dt>
<dd>   This function returns the full path for the current list. A blank 
   path indicates an error condition has occurred. </dd>
<br>
<br>
<dt>
<b>OUTPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>path&nbsp;&nbsp;&nbsp;</tt></td><td>   The path corresponding to the current list. <br>&nbsp;&nbsp;&nbsp;<span class="type">[character(len=fm_path_name_len)]</span></td>
</tr>
</table>
</dd>
<br>
</dl>
</li>
<li>
<a name="fm_get_length"></a>
<h4>fm_get_length</h4>
<pre>length = <b>fm_get_length</b> (name)</pre>
<dl>
<dt>
<b>DESCRIPTION</b>
</dt>
<dd>   This function returns the list or entry length for the named list or entry.
   If the named field or entry does not exist, a value of 0 is returned. </dd>
<br>
<br>
<dt>
<b>INPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>name&nbsp;&nbsp;&nbsp;</tt></td><td>   The name of a list or entry that the user wishes to get the length of. <br>&nbsp;&nbsp;&nbsp;<span class="type">[character(len=*)]</span></td>
</tr>
</table>
</dd>
<br>
<dt>
<b>OUTPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>length&nbsp;&nbsp;&nbsp;</tt></td><td>   The number of elements that the field name has. <br>&nbsp;&nbsp;&nbsp;<span class="type">[integer]</span></td>
</tr>
</table>
</dd>
<br>
</dl>
</li>
<li>
<a name="fm_get_type"></a>
<h4>fm_get_type</h4>
<pre>name_field_type = <b>fm_get_type</b> (name)</pre>
<dl>
<dt>
<b>DESCRIPTION</b>
</dt>
<dd>   This function returns the type of the field for name.
   This indicates whether the named field is a "list" (has children fields),
   or has values of type "integer", "real", "logical" or "string".
   If it does not exist it returns a blank string. </dd>
<br>
<br>
<dt>
<b>INPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>name&nbsp;&nbsp;&nbsp;</tt></td><td>   The name of a field that the user wishes to find the type of. <br>&nbsp;&nbsp;&nbsp;<span class="type">[character(len=*)]</span></td>
</tr>
</table>
</dd>
<br>
<dt>
<b>OUTPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>name_field_type&nbsp;&nbsp;&nbsp;</tt></td><td>   A string containing the type of the named field. <br>&nbsp;&nbsp;&nbsp;<span class="type">[character(len=8)]</span></td>
</tr>
</table>
</dd>
<br>
</dl>
</li>
<li>
<a name="fm_get_value"></a>
<h4>fm_get_value</h4>
<pre>success = <b>fm_get_value</b> (name, value, index)</pre>
<dl>
<dt>
<b>DESCRIPTION</b>
</dt>
<dd>   Find and extract the value for name. The value may be of type real, 
   integer, logical or character. If a single value from an array  of values 
   is required, an optional index can be supplied.
   Return true for success and false for failure </dd>
<br>
<br>
<dt>
<b>INPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>name&nbsp;&nbsp;&nbsp;</tt></td><td>   The name of a field that the user wishes to get a value for. <br>&nbsp;&nbsp;&nbsp;<span class="type">[character(len=*)]</span></td>
</tr>
<tr>
<td valign="top" align="left"><tt>index&nbsp;&nbsp;&nbsp;</tt></td><td>   An optional index to retrieve a single value from an array. <br>&nbsp;&nbsp;&nbsp;<span class="type">[integer, optional]</span></td>
</tr>
</table>
</dd>
<br>
<dt>
<b>OUTPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>success&nbsp;&nbsp;&nbsp;</tt></td><td>   A flag to indicate whether the function operated with (FALSE) or 
   without (TRUE) errors. <br>&nbsp;&nbsp;&nbsp;<span class="type">[logical]</span></td>
</tr>
<tr>
<td valign="top" align="left"><tt>value&nbsp;&nbsp;&nbsp;</tt></td><td>   The value associated with the named field. <br>&nbsp;&nbsp;&nbsp;<span class="type">[integer, real, logical or character]</span></td>
</tr>
</table>
</dd>
<br>
</dl>
</li>
<li>
<a name="fm_intersection"></a>
<h4>fm_intersection</h4>
<pre>return_p =&gt; <b>fm_intersection</b> (lists,dim)</pre>
<dl>
<dt>
<b>DESCRIPTION</b>
</dt>
<dd>   Return a pointer to an fm_array_list of the intersection
   of an array of lists, ignoring the contents of the values,
   but just returning the names.
   Return false on the end of the intersection. </dd>
<br>
<br>
<dt>
<b>INPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>dim&nbsp;&nbsp;&nbsp;</tt></td><td>   The dimension of lists. <br>&nbsp;&nbsp;&nbsp;<span class="type">[dim]</span></td>
</tr>
<tr>
<td valign="top" align="left"><tt>lists&nbsp;&nbsp;&nbsp;</tt></td><td>   A list of fields that the user wishes to find the common fields of. <br>&nbsp;&nbsp;&nbsp;<span class="type">[character(len=*), dimension(dim)]</span></td>
</tr>
</table>
</dd>
<br>
<dt>
<b>OUTPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>return_p&nbsp;&nbsp;&nbsp;</tt></td><td>   A pointer to a list of names that are common to the fields provided in 
   lists. <br>&nbsp;&nbsp;&nbsp;<span class="type">[type (fm_array_list_def), pointer]</span></td>
</tr>
</table>
</dd>
<br>
</dl>
</li>
<li>
<a name="fm_loop_over_list"></a>
<h4>fm_loop_over_list</h4>
<pre>success = <b>fm_loop_over_list</b> (list, name, field_type, index)</pre>
<dl>
<dt>
<b>DESCRIPTION</b>
</dt>
<dd>   Loop over the list, setting the name, type and index
   of the next field. Return false at the end of the loop. </dd>
<br>
<br>
<dt>
<b>INPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>list&nbsp;&nbsp;&nbsp;</tt></td><td>   The name of a list to loop over. <br>&nbsp;&nbsp;&nbsp;<span class="type">[character(len=*)]</span></td>
</tr>
</table>
</dd>
<br>
<dt>
<b>OUTPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>success&nbsp;&nbsp;&nbsp;</tt></td><td>   A flag to indicate whether the function operated with (FALSE) or 
   without (TRUE) errors. <br>&nbsp;&nbsp;&nbsp;<span class="type">[logical]</span></td>
</tr>
<tr>
<td valign="top" align="left"><tt>name&nbsp;&nbsp;&nbsp;</tt></td><td>   The name of a field from list. <br>&nbsp;&nbsp;&nbsp;<span class="type">[character(len=*)]</span></td>
</tr>
<tr>
<td valign="top" align="left"><tt>field_type&nbsp;&nbsp;&nbsp;</tt></td><td>   The type of a list entry. <br>&nbsp;&nbsp;&nbsp;<span class="type">[character(len=fm_type_name_len)]</span></td>
</tr>
<tr>
<td valign="top" align="left"><tt>index&nbsp;&nbsp;&nbsp;</tt></td><td>   The index of tje field within the list. <br>&nbsp;&nbsp;&nbsp;<span class="type">[integer]</span></td>
</tr>
</table>
</dd>
<br>
</dl>
</li>
<li>
<a name="fm_new_list"></a>
<h4>fm_new_list</h4>
<pre>index = <b>fm_new_list</b> (name, create, keep)</pre>
<dl>
<dt>
<b>DESCRIPTION</b>
</dt>
<dd>   Allocate and initialize a new list and return the index of the list. 
   If an error occurs return the parameter NO_FIELD. </dd>
<br>
<br>
<dt>
<b>INPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>name&nbsp;&nbsp;&nbsp;</tt></td><td>   The name of a list that the user wishes to create. <br>&nbsp;&nbsp;&nbsp;<span class="type">[character(len=*)]</span></td>
</tr>
<tr>
<td valign="top" align="left"><tt>create&nbsp;&nbsp;&nbsp;</tt></td><td>   If present and .true., create the list if it does not exist. <br>&nbsp;&nbsp;&nbsp;<span class="type">[logical, optional]</span></td>
</tr>
<tr>
<td valign="top" align="left"><tt>keep&nbsp;&nbsp;&nbsp;</tt></td><td>   If present and .true., make this list the current list. <br>&nbsp;&nbsp;&nbsp;<span class="type">[logical, optional]</span></td>
</tr>
</table>
</dd>
<br>
<dt>
<b>OUTPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>index&nbsp;&nbsp;&nbsp;</tt></td><td>   The index of the newly created list. <br>&nbsp;&nbsp;&nbsp;<span class="type">[integer]</span></td>
</tr>
</table>
</dd>
<br>
</dl>
</li>
<li>
<a name="fm_new_value"></a>
<h4>fm_new_value</h4>
<pre>field_index = <b>fm_new_value</b> (name, value, [create], [index], [append])</pre>
<dl>
<dt>
<b>DESCRIPTION</b>
</dt>
<dd>   Allocate and initialize a new value and return the index.
   If an error condition occurs the parameter NO_FIELD is returned.
   <br>
<br>
   If the type of the field is changing (e.g. real values being transformed to
   integers), then any previous values for the field are removed and replaced 
   by the value passed in the present call to this function.
   <br>
<br>
   If append is present and .true., then index cannot be greater than 0 if 
   it is present. </dd>
<br>
<br>
<dt>
<b>INPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>name&nbsp;&nbsp;&nbsp;</tt></td><td>   The name of a field that the user wishes to create a value for. <br>&nbsp;&nbsp;&nbsp;<span class="type">[character(len=*)]</span></td>
</tr>
<tr>
<td valign="top" align="left"><tt>value&nbsp;&nbsp;&nbsp;</tt></td><td>   The value that the user wishes to apply to the named field. <br>&nbsp;&nbsp;&nbsp;<span class="type">[integer, real, logical, or character(len=*)]</span></td>
</tr>
<tr>
<td valign="top" align="left"><tt>create&nbsp;&nbsp;&nbsp;</tt></td><td>   If present and .true., then a value for this field will be created. <br>&nbsp;&nbsp;&nbsp;<span class="type">[logical, optional]</span></td>
</tr>
<tr>
<td valign="top" align="left"><tt>index&nbsp;&nbsp;&nbsp;</tt></td><td>   The index to an array of values that the user wishes to apply a new value. <br>&nbsp;&nbsp;&nbsp;<span class="type">[integer, optional]</span></td>
</tr>
<tr>
<td valign="top" align="left"><tt>append&nbsp;&nbsp;&nbsp;</tt></td><td>   If present and .true., then append the value to an array of the present 
   values. If present and .true., then index cannot be greater than 0. <br>&nbsp;&nbsp;&nbsp;<span class="type">[logical, optional]</span></td>
</tr>
</table>
</dd>
<br>
<dt>
<b>OUTPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>field_index&nbsp;&nbsp;&nbsp;</tt></td><td>   An index for the named field. <br>&nbsp;&nbsp;&nbsp;<span class="type">[integer]</span></td>
</tr>
</table>
</dd>
<br>
</dl>
</li>
<li>
<a name="fm_reset_loop"></a>
<h4>fm_reset_loop</h4>
<pre>
<b>call fm_reset_loop </b>
</pre>
<dl>
<dt>
<b>DESCRIPTION</b>
</dt>
<dd>   Resets the loop variable. For use in conjunction with fm_loop_over_list. </dd>
<br>
<br>
</dl>
</li>
<li>
<a name="fm_return_root"></a>
<h4>fm_return_root</h4>
<pre>
<b>call fm_return_root </b>
</pre>
<dl>
<dt>
<b>DESCRIPTION</b>
</dt>
<dd>   Return the root list to the value at initialization. 
   For use in conjunction with fm_change_root. 
   <br>
<br>
   Users should use this routine before leaving their routine if they 
   previously used fm_change_root. </dd>
<br>
<br>
</dl>
</li>
<li>
<a name="fm_modify_name"></a>
<h4>fm_modify_name</h4>
<pre>success = <b>fm_modify_name</b> (oldname, newname)</pre>
<dl>
<dt>
<b>DESCRIPTION</b>
</dt>
<dd>   Function to modify the name of a field. 
   Should be used with caution. </dd>
<br>
<br>
<dt>
<b>INPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>oldname&nbsp;&nbsp;&nbsp;</tt></td><td>   The name of a field that the user wishes to change the name of. <br>&nbsp;&nbsp;&nbsp;<span class="type">[character(len=*)]</span></td>
</tr>
<tr>
<td valign="top" align="left"><tt>newname&nbsp;&nbsp;&nbsp;</tt></td><td>   The name that the user wishes to change the name of the field to. <br>&nbsp;&nbsp;&nbsp;<span class="type">[character(len=*)]</span></td>
</tr>
</table>
</dd>
<br>
<dt>
<b>OUTPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>success&nbsp;&nbsp;&nbsp;</tt></td><td>   A flag to indicate whether the function operated with (FALSE) or 
   without (TRUE) errors. <br>&nbsp;&nbsp;&nbsp;<span class="type">[logical]</span></td>
</tr>
</table>
</dd>
<br>
</dl>
</li>
<li>
<a name="fm_query_method"></a>
<h4>fm_query_method</h4>
<pre>success = <b>fm_query_method</b> (name, method_name, method_control)</pre>
<dl>
<dt>
<b>DESCRIPTION</b>
</dt>
<dd>   Given a name return a list of method names and control strings.
   This function should return strings similar to those in the field
   table if a comma delimited format is being used. </dd>
<br>
<br>
<dt>
<b>INPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>name&nbsp;&nbsp;&nbsp;</tt></td><td>   The name of a list that the user wishes to change to. <br>&nbsp;&nbsp;&nbsp;<span class="type">[character(len=*)]</span></td>
</tr>
</table>
</dd>
<br>
<dt>
<b>OUTPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>success&nbsp;&nbsp;&nbsp;</tt></td><td>   A flag to indicate whether the function operated with (FALSE) or 
   without (TRUE) errors. <br>&nbsp;&nbsp;&nbsp;<span class="type">[logical]</span></td>
</tr>
<tr>
<td valign="top" align="left"><tt>method_name&nbsp;&nbsp;&nbsp;</tt></td><td>   The name of a parameter associated with the named field. <br>&nbsp;&nbsp;&nbsp;<span class="type">[character(len=*)]</span></td>
</tr>
<tr>
<td valign="top" align="left"><tt>method_control&nbsp;&nbsp;&nbsp;</tt></td><td>   The value of parameters associated with the named field. <br>&nbsp;&nbsp;&nbsp;<span class="type">[character(len=*)]</span></td>
</tr>
</table>
</dd>
<br>
</dl>
</li>
<li>
<a name="fm_copy_list"></a>
<h4>fm_copy_list</h4>
<pre>index = <b>fm_copy_list</b> (list_name, suffix, create)</pre>
<dl>
<dt>
<b>DESCRIPTION</b>
</dt>
<dd>   Given the name of a pre-existing field and a suffix, this function
   will create a new field. The name of the new field will be that of 
   the old field with a suffix supplied by the user. </dd>
<br>
<br>
<dt>
<b>INPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>list_name&nbsp;&nbsp;&nbsp;</tt></td><td>   The name of a field that the user wishes to copy.. <br>&nbsp;&nbsp;&nbsp;<span class="type">[character(len=*)]</span></td>
</tr>
<tr>
<td valign="top" align="left"><tt>suffix&nbsp;&nbsp;&nbsp;</tt></td><td>   The suffix that will be added to list_name when the field is copied. <br>&nbsp;&nbsp;&nbsp;<span class="type">[character(len=*)]</span></td>
</tr>
</table>
</dd>
<br>
<dt>
<b>OUTPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>index&nbsp;&nbsp;&nbsp;</tt></td><td>   The index of the field that has been created by the copy. <br>&nbsp;&nbsp;&nbsp;<span class="type">[integer]</span></td>
</tr>
</table>
</dd>
<br>
</dl>
</li>
<li>
<a name="fm_find_methods"></a>
<h4>fm_find_methods</h4>
<pre>success = <b>fm_find_methods</b> (list_name, methods, control )</pre>
<dl>
<dt>
<b>DESCRIPTION</b>
</dt>
<dd>   This function retrieves all the methods associated with a field.
   This is different from fm_query_method in that this function gets all
   the methods associated as opposed to 1 method. </dd>
<br>
<br>
<dt>
<b>INPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>list_name&nbsp;&nbsp;&nbsp;</tt></td><td>   The name of a list that the user wishes to find methods for. <br>&nbsp;&nbsp;&nbsp;<span class="type">[character(len=*)]</span></td>
</tr>
</table>
</dd>
<br>
<dt>
<b>OUTPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>success&nbsp;&nbsp;&nbsp;</tt></td><td>   A flag to indicate whether the function operated with (FALSE) or 
   without (TRUE) errors. <br>&nbsp;&nbsp;&nbsp;<span class="type">[logical]</span></td>
</tr>
<tr>
<td valign="top" align="left"><tt>methods&nbsp;&nbsp;&nbsp;</tt></td><td>   An array of the methods associated with list_name. <br>&nbsp;&nbsp;&nbsp;<span class="type">[character(len=*)]</span></td>
</tr>
<tr>
<td valign="top" align="left"><tt>control&nbsp;&nbsp;&nbsp;</tt></td><td>   An array of the parameters associated with methods. <br>&nbsp;&nbsp;&nbsp;<span class="type">[character(len=*)]</span></td>
</tr>
</table>
</dd>
<br>
</dl>
</li>
<li>
<a name="fm_set_verbosity"></a>
<h4>fm_set_verbosity</h4>
<pre>
<b>call fm_set_verbosity </b>(verbosity)</pre>
<dl>
<dt>
<b>DESCRIPTION</b>
</dt>
<dd>   This subroutine will set the level of verbosity in the module.
   Currently, verbosity is either on (1) or off (0). However,
   in the future, "on" may have more granularity. If no argument
   is given, then, if verbosity is on it will be turned off, and
   is off, will be turned to the default on level.
   If verbosity is negative then it is turned off.
   Values greater than the maximum will be set to the maximum. </dd>
<br>
<br>
<dt>
<b>INPUT</b>
</dt>
<dd>
<table border="0">
<tr>
<td valign="top" align="left"><tt>verbosity&nbsp;&nbsp;&nbsp;</tt></td><td>   The level of verbosity required by the user. <br>&nbsp;&nbsp;&nbsp;<span class="type">[integer, optional]</span></td>
</tr>
</table>
</dd>
<br>
</dl>
</li>
</ol>
<!-- END PUBLIC ROUTINES -->
<a name="PUBLIC TYPES"></a>
<!-- BEGIN PUBLIC TYPES -->
<hr>
<h4>PUBLIC TYPES</h4>
<div>
<b>method_type</b>
<br>
<br>
<div>
<dl>   This method_type is a way to allow a component module to alter the parameters it needs
   for various tracers. In essence this is a way to modify a namelist. A namelist can supply
   default parameters for all tracers. This  method will allow the user to modify these
   default parameters for an individual tracer. An example could be that  the user wishes to
   use second order advection on a tracer and also use fourth order advection on a second
   tracer  within the same model run. The default advection could be second order and the
   field table would then indicate  that the second tracer requires fourth order advection.
   This would be parsed by the advection routine.
   <br>
<br> 
<br>
<br>
<dt>
<tt>method_type :: method_type</tt>
</dt>
<dl>   This string represents a tag that a module using this method can
   key on. Typically this should contain some reference to the module
   that is calling it. <br>
<span class="type">[character, dimension(128)]</span>
</dl>
<dt>
<tt>method_type :: method_name</tt>
</dt>
<dl>   This is the name of a method which the module can parse and use
   to assign different default values to a field method. <br>
<span class="type">[character, dimension(128)]</span>
</dl>
<dt>
<tt>method_type :: method_control</tt>
</dt>
<dl>   This is the string containing parameters that the module can use
   as values  for a field method. These should override default
   values within the module. <br>
<span class="type">[character, dimension(256)]</span>
</dl>
</dl>
</div>
</div>
<br>
<div>
<b>method_type_short</b>
<br>
<br>
<div>
<dl>   This method_type is the same as method_type except that the
   method_control string is not present. This is used when you wish to
   change to a scheme within a module but do not need to pass 
   parameters. <br>
<br>
<dt>
<tt>method_type_short :: method_type</tt>
</dt>
<dl>   see method_type :: method_type above. <br>
<span class="type">[character, dimension(128)]</span>
</dl>
<dt>
<tt>method_type_short :: method_name</tt>
</dt>
<dl>   see method_type :: method_name above. <br>
<span class="type">[character, dimension(128)]</span>
</dl>
</dl>
</div>
</div>
<br>
<div>
<b>method_type_very_short</b>
<br>
<br>
<div>
<dl>   This method_type is the same as method_type except that the
   method_control and method_name strings are not present. This is used
   when you wish to change to a scheme within a module but do not need
   to pass  parameters. <br>
<br>
<dt>
<tt>method_type_short :: method_type</tt>
</dt>
<dl>   see method_type :: method_type above. <br>
<span class="type">[character, dimension(128)]</span>
</dl>
</dl>
</div>
</div>
<br>
<!-- END PUBLIC TYPES -->
<a name="NAMELIST"></a>
<!-- BEGIN NAMELIST -->
<!-- END NAMELIST --><a name="DIAGNOSTIC FIELDS"></a>
<!-- BEGIN DIAGNOSTIC FIELDS -->
<!-- END DIAGNOSTIC FIELDS --><a name="DATA SETS"></a>
<!-- BEGIN DATA SETS -->
<hr>
<h4>DATA SETS</h4>
<div>None.<br>
<br>
</div>
<!-- END DATA SETS -->
<a name="PUBLIC CODE"></a>
<!-- BEGIN PUBLIC CODE -->
<!-- END PUBLIC CODE --><a name="ERROR MESSAGES"></a>
<!-- BEGIN ERROR MESSAGES -->
<hr>
<h4>ERROR MESSAGES</h4>
<div>
<dl>
<dt>
<b>NOTE in field_manager_init</b>
</dt>
<dd>
<span class="errmsg">No field table available, so no fields are being registered.</span>
</dd>
<dd>   The field table does not exist. </dd>
<dt>
<b>FATAL in field_manager_init</b>
</dt>
<dd>
<span class="errmsg">Too many fields in field table header entry.</span>
</dd>
<dd>   There are more that 3 fields in the field table header entry. 
   The entry should look like    "Field_Type","Model_Type","Field_Name"    or   "Field_Type","Model_Type" </dd>
<dt>
<b>FATAL in field_manager_init</b>
</dt>
<dd>
<span class="errmsg">Unterminated field in field table header entry.</span>
</dd>
<dd>   There is an unterminated or unquoted string in the field table entry.
   call mpp_error(FATAL,trim(error_header)//'Unterminated field in field_table header entry.'//trim(record)) </dd>
<dt>
<b>NOTE in field_manager_init</b>
</dt>
<dd>
<span class="errmsg">Creating list name = list_name.</span>
</dd>
<dd>   A field is being created called list_name. </dd>
<dt>
<b>FATAL in field_manager_init</b>
</dt>
<dd>
<span class="errmsg">Could not set field list for list_name.</span>
</dd>
<dd>   A field called list_name could not be created. </dd>
<dt>
<b>FATAL in field_manager_init</b>
</dt>
<dd>
<span class="errmsg">The model name is unrecognised : model_name</span>
</dd>
<dd>   The model name being supplied in the field entry is unrecognised.
   This should be the second string in the first line of the field entry.
   Recognised names are atmos_mod, ice_mod, land_mod and ocean_mod. </dd>
<dt>
<b>FATAL in field_manager_init</b>
</dt>
<dd>
<span class="errmsg">max fields exceeded</span>
</dd>
<dd>   Maximum number of fields for this module has been exceeded. </dd>
<dt>
<b>FATAL in field_manager_init</b>
</dt>
<dd>
<span class="errmsg">Too many fields in field entry.</span>
</dd>
<dd>   There are more that 3 fields in the tracer entry. This is probably due
   to separating the parameters entry into multiple strings. 
   The entry should look like    "Type","Name","Control1=XXX,Control2=YYY"    and not like   "Type","Name","Control1=XXX","Control2=YYY" </dd>
<dt>
<b>FATAL in field_manager_init</b>
</dt>
<dd>
<span class="errmsg">Unterminated field in field entry.</span>
</dd>
<dd>   There is an unterminated or unquoted string in the field table entry. </dd>
<dt>
<b>FATAL in field_manager_init</b>
</dt>
<dd>
<span class="errmsg">Unterminated field in field entry.</span>
</dd>
<dd>   Bad format for field entry (comma without equals sign) </dd>
<dt>
<b>FATAL in field_manager_init</b>
</dt>
<dd>
<span class="errmsg">Unterminated field in field entry.</span>
</dd>
<dd>   Too many fields in field entry </dd>
<dt>
<b>FATAL in field_manager_init</b>
</dt>
<dd>
<span class="errmsg">Maximum number of methods for field exceeded</span>
</dd>
<dd>   Maximum number of methods allowed for entries in the field table has been exceeded. </dd>
<dt>
<b>NOTE in field_manager_init</b>
</dt>
<dd>
<span class="errmsg">Field with identical name and model name duplicate found, skipping</span>
</dd>
<dd>   The name of the field and the model name are identical. Skipping that field. </dd>
<dt>
<b>FATAL in field_manager_init</b>
</dt>
<dd>
<span class="errmsg">error reading field table</span>
</dd>
<dd>   There is an error in reading the field table. </dd>
<dt>
<b>FATAL in get_field_info</b>
</dt>
<dd>
<span class="errmsg">invalid field index</span>
</dd>
<dd>   The field index is invalid because it is less than 1 or greater than the 
   number of fields. </dd>
<dt>
<b>FATAL in get_field_method</b>
</dt>
<dd>
<span class="errmsg">invalid field index</span>
</dd>
<dd>   The field index is invalid because it is less than 1 or greater than the 
   number of fields. </dd>
<dt>
<b>FATAL in get_field_method</b>
</dt>
<dd>
<span class="errmsg">invalid method index</span>
</dd>
<dd>   The method index is invalid because it is less than 1 or greater than 
   the number of methods. </dd>
<dt>
<b>FATAL in get_field_methods</b>
</dt>
<dd>
<span class="errmsg">invalid field index</span>
</dd>
<dd>   The field index is invalid because it is less than 1 or greater than the 
   number of fields. </dd>
<dt>
<b>FATAL in get_field_methods</b>
</dt>
<dd>
<span class="errmsg">method array too small</span>
</dd>
<dd>   The method array is smaller than the number of methods. </dd>
</dl>
<br>
</div>
<!-- END ERROR MESSAGES -->
<hr>
<div align="right">
<font size="-1"><a href="#TOP">top</a></font>
</div>
</body>
</html>
